#include <cstdint>
#include "taco.h"
#include <iostream>

void spmv2(int A1_size, int *A2_pos, int *A2_idx, double *A_vals, double *y_vals, double *x_vals);

void spmv(int A1_size, int *A2_pos, int *A2_idx, double *A_vals, double *y_vals, double *x_vals) {
  // Generated by the Tensor Algebra Compiler (tensor-compiler.org)
  for (int32_t iA = 6000; iA < 15000/*A1_size*/; iA++) {
    double tj = 0;
    for (int32_t pA2 = A2_pos[iA]; pA2 < A2_pos[iA + 1]; pA2++) {
      int32_t jA = A2_idx[pA2];
      tj += A_vals[pA2] * x_vals[jA];
    }
    y_vals[iA] = tj;
  }
}

int main() {
  auto Atensor = taco::read("test.mtx", taco::CSR);
  auto * __restrict__ A = Atensor.getTacoTensorT();
  int A1_size = *(int*)(A->indices[0][0]);
  int* __restrict__ A2_pos = (int*)(A->indices[1][0]);
  int* __restrict__ A2_idx = (int*)(A->indices[1][1]);
  double*  A_vals = (double*)(A->vals);
  const auto &dims = Atensor.getDimensions();

  int  n = dims[0];
  auto *y_vals = new double[n];
  auto *x_vals = new double[n];
  for (int i = 0; i < n; i++) {
    x_vals[i] = 1;
    y_vals[i] = 0;
  }
	volatile int iter_ = 10000;
	int iter = iter_;
	for (int i = 0; i < iter; i++) {
		spmv(A1_size, A2_pos, A2_idx, A_vals, y_vals, x_vals);
	}
  for (int i = 0; i < n; i++) {
    std::cout << y_vals[i] << '\n';
  }
}
